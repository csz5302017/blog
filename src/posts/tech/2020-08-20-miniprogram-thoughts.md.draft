---
permalink: '/posts/2020-08-20-miniprogram-thoughts.html'
title: '关于微信小程序的思考'
date: 2020-08-20T06:48:52.598Z
tags: []
---

最早接触微信小程序是大概是在 16 年，那时候差不多就是小程序刚刚起步的时候，当时参与了公司一个练习/技术积累性质的小程序项目。那时候觉得小程序实在是太挫了，要什么就没有什么，开发工具本身还一大堆问题。

最近分别因为工作与个人原因又参与了一段时间小程序开发，发现当年的问题已大有改观。小程序开发的整体形态已经从当年的缺胳膊少腿变成了麻雀虽小五脏俱全。但是某些方面却也还是没有改观，依然的挫。

## 整体设计

小程序的整体设计原则很明显：让大家可以以最小的学习成本干最多的活。大家不是用 Vue.js 习惯了吗，因此它就仿照其实现了自己的代码框架。

### 用 React 的方式写 Vue

```javascript
//index.js
Page({
  data: {
    text: "This is page data."
  },
  onLoad: function(options) {
    // 页面创建时执行
  },
  onShow: function() {
    // 页面出现在前台时执行
  },
  // ...
})
```

是不是很像 Vue 呢？

然而时至今日被人吐槽得最多的，大概就是它这一套框架。因为它抄 Vue，要是一抄到底就算了，我们就当在写 Vue，然而它却仅限于皮毛，抄一点，不抄一点，又改一点，让人非常膈应。

**小程序说是像 Vue，其实本质更像 React**。因为 Vue 与 React 最大的区别之一是在于数据驱动方式：Vue 使用自动监听，而 React 则是手动更新。而小程序在一点上靠向了 React 这边：在更新数据时不能直接赋值，必须使用 `setData` 函数通知 view 层更新。

这就造成了困惑点：写习惯了 Vue 的人会习惯性的赋值，发现没有用，懵逼了半天以后找到原因，原来某处忘记使用 `setData` 了。写习惯了 React 的人会觉得声明式的组件/页面不伦不类，class/functional 两不沾。

至于为什么会这样，我觉得是因为负责小程序框架的开发人员偷懒了：既想要利用声明式设计的便利，又不想实现复杂的自动监听。因为如果是技术层面的原因，没有理由会写成这样。

另一个困惑点是：定义在 Vue 实例上的 data 可以直接通过 `this` 访问到，而定义在小程序实例上的 data 类似于 React class component 中的 `this.state`， 必须通过 `this.data` 才能访问到。

诸如此类，小程序这种「类 Vue 实 React」的做法实际上是伤害了习惯使用 Vue.js 的开发者，强迫进行思维转变的过程中经常会不经意地就写出了 BUG。

### 一分为四的组件

另一点广为诟病的问题是：每个小程序组件/页面都由四个部分组成：定义 (json)、页面 (wxml)、样式 (wxss)、逻辑 (js)。

```
index
├── index.js
├── index.json
├── index.wxml
└── index.wxss
```

这很烦。

React / Vue 都用自己的方式实现了组件自身的高内聚：将所有与组件相关的资源合并到一个文件内。这样无论是从哪个方面来说都比分散的文件更为优秀。但是小程序框架没有这么做，将这部分的维护成本抛给了小程序开发者。

### 文件名后缀

`.js` `.json` 可以接受，`.wxml` `.wxss` 是什么东西？

如果说前面的是情有可原，那这个我觉得完全就是 kpi 命名了。领导说：要有发明。于是就有了 `.wxml` `.wxss`。里面的东西和 `.xml` `.css` 有什么不同吗？

没有（内嵌在 `.wxml` 中的 `wxs` 除外，这又是另一个奇葩）。

> 为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。
> 
> 与 CSS 相比，WXSS 扩展的特性有：尺寸单位、样式导入

先不说 CSS 本身就已经具有了样式导入的特性，加一个尺寸单位就要起新的名字，也是够了。

更可恶的是，这个操作开了先河，后面出现了更多妖魔鬼怪：`.qml` `.qss` `.ttml` `.ttss`，真的够了。

### 模板指令

有了 Vue.js 设计优秀的模板指令作为「前车之鉴」，小程序还是发明了一套自己的指令。

#### 指令内容转义

它们的指令之间的区别除了语法以外，还有一点在于：Vue.js 中的指令内容默认是来自于组件中的变量，而小程序默认是字符串，必须要经过双大括号转义才能读取变量。

比如条件渲染指令，在 vue 中：

```html
<div v-if="show">...</div>
```

在小程序中：

```html
<view wx:if="{{show}}">...</view>
```

诸如此类，这种转义实际上是完全没有必要的。99% 的场景中指令都会绑定变量，绑定常量的少之又少。如此一来就导致了模板代码中出现大量无必要的转义符号。同时这也是又一个困惑点：既遵循了 Vue 的规则又打破了规则。

如果小程序是为了统一所有变量全部使用转义，那也无可厚非。但是在 `wxml` 中还有特例：事件绑定指令不需要转义。

例如：

```html
<view bind:tap="onTap">...</view>
```

这里如果写了转义，甚至会导致无法访问到该函数。这就有点精分了。

#### 指令语法限制

Vue.js 中的指令中可以无限制地执行 JavaScript 语句，如访问 data、访问 computed 变量、访问方法，或各种复杂的 JavaScript 运算，等等。唯一的限制时，涉及到的变量必须要是定义在了 Vue 实例中的变量。

然而到了小程序这里事情就不一样了，小程序只支持有限的运算与访问：仅可以访问 `data` 下的变量，仅支持执行三元运算、算数运算、逻辑运算、字符串运算以及取值运算，以及以上运算之间的组合。为了解决访问方法的问题小程序方还特意「发明」了一种称之为 `wxs` 的语言来内嵌在 `wxml` 中。这又是一处让人感到困惑的地方。

## 自定义组件

小程序一开始是没有自定义组件的，从基础库版本 1.6.3 开始才拥有了这个能力。

大概是设计者发现当时的 `Page` 接口没有办法兼容，因此新加了一个 `Component` 接口来实现自定义组件，同时允许使用该接口来替代原有接口作为页面入口。

除了使用 `Component` 以外，开发者还必须在 `.json` 配置中指定 `"component": true`，该「组件」才能真正作为一个组件为别的组件或页面所引用。

自定义组件基本上就是照抄 Vue.js 的概念：props, slot, 等等。然而跟 `Page` 一样缺胳膊少腿。前面提到的规则，在自定义组件中仍然适用。

组件的槽点实在太多，细细数下来，也许每一个 feature 都是槽点。

### 引用

一个组件/页面想要引用另一个组件，必须在 `.json` 配置中显式声明：

```json
{
  "usingComponents": {
    "component-tag-name": "path/to/the/custom/component"
  }
}
```

才能在相应的 `wxml` 中使用：

```html
<view>
  <component-tag-name .../>
</view>
```

由此扩展到其它在 `.json` 文件中的定义，可以发现很多定义实际上都是没有必要的，可以说整个 `.json` 文件都是多余的。

ES6 import 都那么多年了，小程序又回到了老路上。其实综合以上的一些点，如一个组件要拆分四份文件，要写 `.json` 配置，以及各种怪异之处，可以作出一个总结：实现一个更加现代化的技术框架并不是不可行，而仅仅是因为框架设计/开发者不去做。不想去写各种 loader，不想去支持 jsx，怎么对微信方便怎么来。

作为一个后 Angular 时代出现的前端开发框架，不支持以 import 的方式来引入组件简直是匪夷所思。也许只有商业化的东西才能如此不堪吧。

### 生命周期

观察以下构造函数：

```javascript
Component({
  lifetimes: {
    attached: function() {
      // 在组件实例进入页面节点树时执行
    },
    detached: function() {
      // 在组件实例被从页面节点树移除时执行
    },
  },
  // 以下是旧式的定义方式，可以保持对 <2.2.3 版本基础库的兼容
  attached: function() {
    // 在组件实例进入页面节点树时执行
  },
  detached: function() {
    // 在组件实例被从页面节点树移除时执行
  },

  pageLifetimes: {
    // 组件所在页面的生命周期函数
    show: function () { },
    hide: function () { },
    resize: function () { },
  },

  methods: {
    onLoad () {
      // ...
    } 
  }
})
```

四个字来形容：混乱不堪。

* 组件的生命周期函数，既可以直接写在实例上，也可以写在 `lifetimes` 字段中。
* 页面的生命周期函数，既可以写在 `pageLifetimes` 字段中，也可以写在 `methods` 字段中。

如此设计，出了混淆自己以及开发者以外，没有别的好处。

### behaviors

behaviors 其实就是 Vue.js 中的 mixin，换了个名字。这个特性大概是最原汁原味的了，基本就是 Vue.js 原本的复用逻辑。

```javascript
Component({
  behaviors: [...]
})
```

有了 mixin，组件之间就能更频繁地复用代码。这对开发者来说是友好的。但这同时也是 Vue.js 2.x 时代的眼泪：mixin 本身并不是一个好的方式。这点 3.0 已经做过很多解释了，因为组件混入 mixin 后，很难看出一个属性或方法是来自于哪里的，是来自于 mixin 还是组件本身。当混入多个 mixin 时更甚。

但是，无论怎么说，有总比没有好。当业务逻辑不太复杂时，mixin 依然是一个可以解决问题的选择。

### 纯数据字段

这个 feature，我看到的时候其实是有点懵逼的。官方描述如下：

> 有些情况下，某些 data 中的字段（包括 setData 设置的字段）既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。
> 
> 此时，可以指定这样的数据字段为“纯数据字段”，它们将仅仅被记录在 this.data 中，而不参与任何界面渲染过程，这样有助于提升页面更新性能。

```javascript
Component({
  options: {
    pureDataPattern: /^_/ // 指定所有 _ 开头的数据字段为纯数据字段
  },
  data: {
    a: true, // 普通数据字段
    _b: true, // 纯数据字段
  },
  methods: {
    myMethod() {
      this.data._b // 纯数据字段可以在 this.data 中获取
      this.setData({
        c: true, // 普通数据字段
        _b: true, // 纯数据字段
      })
    }
  }
})
```

> 上述组件中的纯数据字段不会被应用到 WXML 上：

```html
<view wx:if="{{a}}"> 这行会被展示 </view>
<view wx:if="{{_b}}"> 这行不会被展示 </view>
```

我不知道这个 `pureDataPattern` 的意义是什么。直接 `this._b = true` 可以达到完全一致的效果。

未完待续。
